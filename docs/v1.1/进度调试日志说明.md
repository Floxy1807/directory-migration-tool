# 进度调试日志功能说明

## 问题背景

用户反馈在复制大文件时，GUI 界面会卡住，日志窗口长时间没有输出，不确定程序是否正常运行。

### 典型现象

```
[11:27:36] 开始还原文件 (robocopy)...
[11:27:36] [Robocopy-还原] 开始时间: 2025年11月7日 11:27:36
[11:27:41] [Robocopy-还原] ------------------------------------------------------------------------------
[11:28:16] [Robocopy-还原] 已结束: 2025年11月7日 11:27:41  <-- 35秒没有日志！
```

**用户疑问**：
- 😰 程序是不是卡死了？
- 😰 需要强制结束吗？
- 😰 进度条为什么不动？

## 解决方案：进度调试日志

### 新增功能

在 Debug 模式下，每次进度更新（每隔 `SampleMilliseconds`）都会输出详细的内部状态到 **Visual Studio 输出窗口**：

```csharp
#if DEBUG
    System.Diagnostics.Debug.WriteLine(
        $"[Progress-{actionName}] " +
        $"Actual: {actualCopiedBytes}, " +
        $"Displayed: {displayedBytes}, " +
        $"Delta: {actualDeltaBytes}, " +
        $"Speed: {speed}, " +
        $"Percent: {percent:F1}%, " +
        $"NoChange: {noChangeCount}");
#endif
```

### 输出示例

#### 正常复制（有进度变化）

```
[Progress-还原] Actual: 512.00 MB, Displayed: 256.00 MB, Delta: 128.00 MB, Speed: 64.00 MB/s, Percent: 15.2%, NoChange: 0
[Progress-还原] Actual: 640.00 MB, Displayed: 384.00 MB, Delta: 128.00 MB, Speed: 64.00 MB/s, Percent: 18.5%, NoChange: 0
[Progress-还原] Actual: 768.00 MB, Displayed: 512.00 MB, Delta: 128.00 MB, Speed: 64.00 MB/s, Percent: 21.8%, NoChange: 0
```

**特征**：
- ✅ `Actual` 逐步增长
- ✅ `Delta` 有实际增量
- ✅ `Speed` 显示正常速度
- ✅ `NoChange = 0` 表示有变化

#### 文件系统报告延迟（卡住的情况）

```
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 12.02 GB, Speed: 0 B/s, Percent: 10.5%, NoChange: 0
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 0 B, Speed: 0 B/s, Percent: 10.5%, NoChange: 1
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 0 B, Speed: 0 B/s, Percent: 10.5%, NoChange: 2
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 0 B, Speed: 0 B/s, Percent: 10.5%, NoChange: 3
...
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 0 B, Speed: 0 B/s, Percent: 10.5%, NoChange: 10
```

**特征**：
- ⚠️ `Actual` 瞬间跳到 12.02 GB（文件系统预分配）
- ⚠️ `Actual` 保持不变（文件系统报告延迟）
- ❌ `Delta = 0`（没有新的增量）
- ❌ `Speed = 0`（无法计算速度）
- ⚠️ `Displayed` 保持不变（速度累加法依赖增量）
- 📈 `NoChange` 持续增加（停滞检测）

## 日志字段说明

| 字段 | 含义 | 来源 | 说明 |
|------|------|------|------|
| **Actual** | 实际扫描到的字节数 | `GetDirectorySize()` | 文件系统报告的目录大小，可能包含预分配空间 |
| **Displayed** | 显示给用户的字节数 | 速度累加计算 | `displayedBytes += smoothedSpeed × deltaTime` |
| **Delta** | 本次采样的增量 | `actualCopiedBytes - prevBytes` | 两次采样之间的实际变化量 |
| **Speed** | 平滑后的速度 | `EMA(Delta / deltaTime)` | 使用指数移动平均平滑后的速度 |
| **Percent** | 当前进度百分比 | `(Displayed / Total) × 80% + 10%` | 映射到 10%-90% 区间 |
| **NoChange** | 连续无变化次数 | 计数器 | 当 Delta=0 时递增，用于检测停滞 |

## 问题诊断流程

### 步骤 1: 启动 Debug 版本

```bash
# 编译 Debug 版本
dotnet build -c Debug

# 或在 Visual Studio 中选择 Debug 配置
```

### 步骤 2: 打开输出窗口

在 Visual Studio 中：
1. 启动调试（F5）
2. 打开输出窗口（Ctrl+Alt+O 或 视图 -> 输出）
3. 确保显示来自 "调试" 的输出

### 步骤 3: 开始复制并观察日志

在输出窗口中搜索 `[Progress` 查看进度日志。

### 步骤 4: 分析日志模式

#### 模式 A: 程序正常工作

```
[Progress] Actual: 增长, Delta: >0, Speed: >0, NoChange: 0
```

**结论**：✅ 一切正常，进度在更新。

#### 模式 B: 文件系统报告延迟

```
[Progress] Actual: 不变, Delta: 0, Speed: 0, NoChange: 递增
```

**结论**：⚠️ Robocopy 在后台工作，但文件系统报告延迟。

**验证方法**：
1. 检查 Robocopy 进程是否存在（任务管理器）
2. 检查目标磁盘是否有写入活动（资源监视器 -> 磁盘）
3. 等待 Robocopy 完成后查看最终日志

#### 模式 C: 真的卡死了

```
没有任何 [Progress] 日志输出
```

**结论**：❌ 进度循环停止了，可能是程序崩溃。

**排查**：
1. 检查是否有异常日志
2. 查看进程是否响应
3. 检查是否有死锁

## 典型问题案例

### 案例 1: 你遇到的问题

**现象**：
- GUI 卡住 35 秒
- 日志窗口没有输出

**Debug 日志显示**：
```
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 0 B, Speed: 0 B/s, NoChange: 1
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 0 B, Speed: 0 B/s, NoChange: 2
...
[Progress-还原] Actual: 12.02 GB, Displayed: 120.00 MB, Delta: 0 B, Speed: 0 B/s, NoChange: 70
```

**分析**：
1. 进度循环正常运行（有日志输出）
2. Robocopy 正常工作（最终日志显示完成）
3. 问题：文件系统一次性预分配了 12.02 GB，然后报告值就不变了
4. 因为 `Delta = 0`，速度累加法无法增长进度
5. 当 `NoChange >= 10` 时，GUI 显示"正在处理..."

**根本原因**：
- Windows NTFS 的稀疏文件或预分配机制
- `GetDirectorySize()` 返回的是逻辑大小，不是实际写入量
- 在实际写入完成前，文件系统报告的大小不变

**改进方案**：
见下一节。

## 改进方向

### 方案 1: 使用最小估算速度

当检测到长时间停滞时，使用一个保守的最小速度来增长进度：

```csharp
if (noChangeCount > 20 && !process.HasExited)
{
    // 使用一个非常保守的最小速度（例如 10 MB/s）
    double minimumSpeed = 10 * 1024 * 1024; // 10 MB/s
    displayedBytes += (long)(minimumSpeed * deltaTime);
}
```

**优点**：
- ✅ 进度条继续缓慢移动
- ✅ 用户知道程序还在工作

**缺点**：
- ⚠️ 进度可能不准确
- ⚠️ 可能超过实际进度

### 方案 2: 解析 Robocopy 输出

通过解析 Robocopy 的标准输出来获取实时进度：

```
	  New File  	  104857600	file1.dat
	45%  <-- 解析这个百分比
```

**优点**：
- ✅ 进度最准确
- ✅ 直接来自 Robocopy

**缺点**：
- ⚠️ 需要解析文本输出
- ⚠️ Robocopy 输出格式可能变化
- ⚠️ 当使用 /NP 时没有百分比输出

### 方案 3: 使用 GetCompressedFileSize API

使用 Windows API 获取实际磁盘占用：

```csharp
[DllImport("kernel32.dll")]
static extern uint GetCompressedFileSize(string lpFileName, out uint lpFileSizeHigh);
```

**优点**：
- ✅ 获取实际写入的字节数
- ✅ 更准确

**缺点**：
- ⚠️ 需要 P/Invoke
- ⚠️ 需要遍历所有文件（性能开销）
- ⚠️ 在某些文件系统上可能不准确

### 方案 4: 显示状态而不是进度

当检测到停滞时，改变显示策略：

```
状态: 正在写入大文件，请耐心等待...
已用时间: 00:02:35
预计总时间: 00:05:00（基于扫描时的统计）
```

**优点**：
- ✅ 不会误导用户
- ✅ 提供有用的信息

**缺点**：
- ⚠️ 没有精确的进度反馈

## 当前实现的优势

虽然存在文件系统报告延迟的问题，但当前的实现已经做了很多优化：

1. ✅ **停滞检测**：`NoChange` 计数器
2. ✅ **自适应显示**：停滞时显示"正在处理..."
3. ✅ **速度累加法**：避免进度瞬间跳跃（大部分情况有效）
4. ✅ **详细调试日志**：便于诊断问题
5. ✅ **不会卡死**：进度循环始终运行

## 总结

通过添加进度调试日志，我们现在可以：

- ✅ **确认程序是否真的卡死**：查看是否有 `[Progress]` 日志
- ✅ **诊断进度停滞原因**：分析 `Delta` 和 `NoChange`
- ✅ **验证速度累加法是否工作**：对比 `Actual` 和 `Displayed`
- ✅ **为进一步优化提供数据**：收集真实场景的日志

这个功能仅在 Debug 模式启用，对 Release 版本零影响！🔍✨

