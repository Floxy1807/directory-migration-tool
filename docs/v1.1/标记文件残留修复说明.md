# 标记文件残留问题修复说明

**更新时间**：2025-11-01  
**修复版本**：v1.1.1  
**问题编号**：#MARKER-RESIDUE

---

## 问题描述

### 症状
用户在取消迁移操作后，再次尝试迁移时，状态检测误判为"复制完成，待创建符号链接"。

### 根本原因
标记文件（`.xinghe-migrate.done` 等）可能在以下场景中残留：

1. **上次迁移遗留**：
   - 第一次迁移成功完成 → 标记文件留在目标目录
   - 执行还原 → 仅清理源目录标记，目标目录标记未清理
   - 第二次迁移到同一目标 → 旧标记干扰状态判断

2. **中断后残留**：
   - 迁移进行到阶段3（复制完成）→ `.xinghe-migrate.done` 已创建
   - 用户取消或崩溃
   - 下次启动检测到 `.done` 存在 → 误判为"复制完成"

---

## 修复方案

### 核心原则
**"每次操作开始时清理旧标记，确保干净的起点"**

### 修改内容

#### 1. 迁移开始时清理旧标记
**文件**：`MigrationCore/Services/MigrationStateDetector.cs`  
**方法**：`CreateMigrateLockFile()`

**修改前**：
```csharp
public static void CreateMigrateLockFile(string targetPath, string sourcePath)
{
    try
    {
        // 删除可能存在的还原标记
        DeleteRestoreMarkers(targetPath);

        string lockFilePath = Path.Combine(targetPath, MigrateLockFile);
        string content = $"SourcePath: {sourcePath}\nStartTime: {DateTime.Now:yyyy-MM-dd HH:mm:ss}";
        File.WriteAllText(lockFilePath, content);
        File.SetAttributes(lockFilePath, FileAttributes.Hidden);
    }
    catch { }
}
```

**修改后**：
```csharp
public static void CreateMigrateLockFile(string targetPath, string sourcePath)
{
    try
    {
        // 删除可能存在的还原标记
        DeleteRestoreMarkers(targetPath);

        // 删除可能存在的旧迁移标记（包括 .lock 和 .done）
        DeleteMigrateMarkers(targetPath);

        string lockFilePath = Path.Combine(targetPath, MigrateLockFile);
        string content = $"SourcePath: {sourcePath}\nStartTime: {DateTime.Now:yyyy-MM-dd HH:mm:ss}";
        File.WriteAllText(lockFilePath, content);
        File.SetAttributes(lockFilePath, FileAttributes.Hidden);
    }
    catch { }
}
```

#### 2. 还原完成后清理目标目录标记
**文件**：`MigrationCore/Services/ReversibleMigrationService.cs`  
**方法**：`CleanupAfterRestoreAsync()`

**修改前**：
```csharp
private async Task CleanupAfterRestoreAsync(IProgress<string>? logProgress)
{
    if (!_keepTargetOnRestore && Directory.Exists(_config.TargetPath))
    {
        // 删除目标数据
    }
    else
    {
        logProgress?.Report("保留目标数据");
    }

    // 清理还原标记
    MigrationStateDetector.DeleteRestoreMarkers(_config.SourcePath);
}
```

**修改后**：
```csharp
private async Task CleanupAfterRestoreAsync(IProgress<string>? logProgress)
{
    if (!_keepTargetOnRestore && Directory.Exists(_config.TargetPath))
    {
        // 删除目标数据（同时清理了所有标记）
    }
    else
    {
        logProgress?.Report("保留目标数据");
        
        // 如果保留目标数据，清理其中的迁移标记文件
        if (Directory.Exists(_config.TargetPath))
        {
            MigrationStateDetector.DeleteMigrateMarkers(_config.TargetPath);
        }
    }

    // 清理还原标记
    MigrationStateDetector.DeleteRestoreMarkers(_config.SourcePath);
}
```

#### 3. 还原开始时清理旧还原标记
**文件**：`MigrationCore/Services/MigrationStateDetector.cs`  
**方法**：`CreateRestoreLockFile()`

**修改前**：
```csharp
public static void CreateRestoreLockFile(string sourcePath, string targetPath)
{
    try
    {
        // 在目标路径创建还原锁文件
        string lockFilePath = Path.Combine(targetPath, RestoreLockFile);
        string content = $"SourcePath: {sourcePath}\nStartTime: {DateTime.Now:yyyy-MM-dd HH:mm:ss}";
        File.WriteAllText(lockFilePath, content);
        File.SetAttributes(lockFilePath, FileAttributes.Hidden);
    }
    catch { }
}
```

**修改后**：
```csharp
public static void CreateRestoreLockFile(string sourcePath, string targetPath)
{
    try
    {
        // 删除可能存在的旧还原标记
        DeleteRestoreMarkers(targetPath);
        
        // 在目标路径创建还原锁文件
        string lockFilePath = Path.Combine(targetPath, RestoreLockFile);
        string content = $"SourcePath: {sourcePath}\nStartTime: {DateTime.Now:yyyy-MM-dd HH:mm:ss}";
        File.WriteAllText(lockFilePath, content);
        File.SetAttributes(lockFilePath, FileAttributes.Hidden);
    }
    catch { }
}
```

---

## 修复效果

### 清理时机总结

| 操作 | 时机 | 清理内容 | 目的 |
|------|------|---------|------|
| **迁移** | 开始（阶段1） | 目标目录的旧迁移标记 + 还原标记 | 确保干净的迁移起点 |
| **还原** | 开始（阶段1） | 目标目录的旧还原标记 | 确保干净的还原起点 |
| **还原** | 完成（阶段6） | 目标目录的迁移标记 + 源目录的还原标记 | 防止标记残留 |
| **迁移回滚** | 失败时 | 目标目录的迁移标记 | 重置到初始状态 |
| **还原回滚** | 失败时 | 目标目录的还原标记 | 重置到初始状态 |

### 场景验证

#### ✅ 场景1：多次迁移同一目标
```
第一次迁移：A → B（成功）
还原：B → A
第二次迁移：A → B
结果：✓ 不会受旧标记干扰，正常迁移
```

#### ✅ 场景2：取消后重试
```
开始迁移：A → B
阶段3完成 → .done 创建
用户取消
下次启动：A → B
结果：✓ 迁移开始时清理旧 .done，状态判断正确
```

#### ✅ 场景3：还原后保留目标数据
```
迁移：A → B（成功）
还原：B → A（保留 B 的数据）
结果：✓ B 中的迁移标记被清理，不影响后续操作
```

#### ✅ 场景4：崩溃恢复
```
迁移：A → B
阶段3完成后崩溃
重启应用
结果：✓ 检测到 .lock 但没有新 .done（旧的已清理），可续传
```

---

## 测试建议

### 手动测试步骤

1. **测试残留标记清理**：
   ```powershell
   # 手动在目标目录创建旧标记
   New-Item "E:\Target\.xinghe-migrate.done" -ItemType File
   
   # 执行迁移
   # 验证：迁移开始时旧标记被删除，创建新的 .lock
   ```

2. **测试取消后重试**：
   ```
   1. 开始迁移 A → B
   2. 等待复制阶段进行中（但未完成）
   3. 点击取消
   4. 再次迁移 A → B
   5. 验证：状态显示正确，可以正常迁移
   ```

3. **测试还原后再迁移**：
   ```
   1. 迁移 A → B（完成）
   2. 还原 B → A（勾选"保留目标数据"）
   3. 查看 B 目录：验证无标记文件
   4. 再次迁移 A → B
   5. 验证：正常迁移，无误判
   ```

---

## 影响范围

- ✅ **向后兼容**：不影响现有已迁移的目录
- ✅ **性能影响**：无（清理操作仅在操作开始时执行一次）
- ✅ **功能影响**：增强了状态检测的准确性
- ✅ **风险评估**：低（仅增加清理逻辑，不改变核心流程）

---

## 总结

本次修复通过在操作开始时主动清理旧标记文件，彻底解决了标记残留导致的状态误判问题。修改遵循"防御性编程"原则，确保每次操作都在干净的环境下开始，提高了系统的健壮性。

